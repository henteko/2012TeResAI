<TITLE>ＤＸライブラリ置き場　ミニテク</TITLE>
<HTML>
	<HEAD>
	</HEAD>
	<BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#003388" VLINK="#800040">
	<TABLE ALIGN="CENTER" WIDTH=800  CELLSPACING=0 CELLPADDING=0 >
		<TR>
		<TD ALIGN="CENTER">
		<FONT SIZE="6" COLOR="#000000"><B>
			ＤＸライブラリミニテクニック
		</FONT>
		</TD></TR>
		<TR><TD>
		<HR>
		<FONT SIZE="3" COLOR="#000000"><B>
			<BR>
			　ここではＤＸライブラリに関するちょっとしたテクニックや、
			ＤＸライブラリとはあんまり関係ないちょっとしたテクニックなどを紹介します。<BR><BR><BR>
			
			
			　<A HREF="#T8">ウインドウモードで起動する</A><BR><BR>
			　<A HREF="#T9">ソフトのタイトルを変更する</A><BR><BR>
			　<A HREF="#T11">アーカイブ機能を使ってファイルを一つに纏める</A><BR><BR>
			　<A HREF="#T1">数値をグラフィックで表示する</A><BR><BR>
			　<A HREF="#T2">使えるＣ言語標準関数集</A><BR><BR>
			　<A HREF="#M1">ソフトが完成したらDebugビルドではなくReleaseビルドを行い処理速度の向上を図る</A><BR><BR>
			　<A HREF="#M2">自作ソフトにオリジナルアイコンを付ける</A><BR><BR>
			　<A HREF="#M3">ＢＭＰやＷＡＶファイルだとデータが読まれてしまうので…</A><BR><BR>
			　<A HREF="#M5">裏画面のすすめ</A><BR><BR>
			　<A HREF="#M6">ゲームの進行速度とリフレッシュレート</A><BR><BR>
			　<A HREF="#M7">『前処理』のすすめ</A><BR><BR>
			　<A HREF="#M10">データ圧縮プログラムについてざっくり学ぶ</A><BR><BR>

			<HR>

			　<FONT COLOR="#007712"><A NAME="T8">ウインドウモードで起動する</A></FONT><BR><BR>
			  
			　ＤＸライブラリは標準では<FONT COLOR="#770000">フルスクリーンモードで起動</FONT>しますが、開発中では
			<FONT COLOR="#770000">ウインドウモードで起動</FONT>したい時があります。何故なら<FONT COLOR="#770000">フルスクリーンモード</FONT>では
			<FONT COLOR="#770000">デバッグ機能が全く使えない</FONT>からです。<BR><BR><BR>

			　とりあえず、<FONT COLOR="#770000">ウインドウモードで起動</FONT>するには <FONT COLOR="#770000">DxLib_Init</FONT> を呼んでいる行の前に<BR><BR>

			<A HREF="dxfunc.html#R11N1">ChangeWindowMode</A>( TRUE ) ;<BR><BR>
			
			　という記述を一行増やしてやるだけ<FONT COLOR="#770000">ウインドウモードで起動</FONT>する事が出来ます。<BR><BR><BR>
			
			　ところで<FONT COLOR="#770000">『デバッグ機能って何？』</FONT>という方の為にちょっと説明しますと、例えば
			<FONT COLOR="#770000">プログラムの実行を指定の個所で止めたり</FONT>、<FONT COLOR="#770000">止めた時点での各変数の状態が見れたり</FONT>と、
			そんな感じの機能です。<BR>
			　まだ<FONT COLOR="#770000">デバッグ機能</FONT>を使った事が無い方は、とりあえず上記の様に <FONT COLOR="#770000">DxLib_Init</FONT> を呼んでいる
			行の前に <FONT COLOR="#770000">ChangeWindowMode( TRUE ) ;</FONT> と記述して、<FONT COLOR="#770000">Visual C++</FONT>をお使いの方は、
			何処か適当な行で<FONT COLOR="#770000">キーボードのＦ９</FONT>を押してから<FONT COLOR="#770000">Ｆ５</FONT>でソフトを起動してみてください、恐らく<FONT COLOR="#770000">Ｆ９</FONT>を
			押した行でプログラムが止まるはずです。( <FONT COLOR="#770000">Borland C++</FONT> での方法はちょっと下のほうに書いてあります)<BR>
			　止まった時に <FONT COLOR="#770000">Visual C++</FONT> 上にそれらしいウインドウが出現していれば問題あり
			ませんが、もし普段となにも変わらないウインドウしか表示されていなかったらメニューの
			<FONT COLOR="#770000">『デバッグ』→『ウインドウ』</FONT>の中の<FONT COLOR="#770000">『ローカル』</FONT>や<FONT COLOR="#770000">『呼び出し履歴』</FONT>辺りを表示させて
			みて下さい( <FONT COLOR="#770000">VisualC++ 6.0</FONT> では<FONT COLOR="#770000">『表示』→『デバッグウインドウ』</FONT>の中の<FONT COLOR="#770000">『変数』</FONT>や
			<FONT COLOR="#770000">『コールスタック』</FONT>)恐らく<FONT COLOR="#770000">停止した関数内で宣言されている変数の値</FONT>や、
			<FONT COLOR="#770000">止まった行に来るまでにどの関数を辿ってきたか</FONT>を確認できると思います。<BR><BR>

			　この機能は非常に便利ですので、使った事がない方は是非使ってみてください。<BR><BR><BR>


			　<FONT COLOR="#770000">Borland C++</FONT> では、<FONT COLOR="#770000">デバッグ機能が Borland C++ とは別のソフト</FONT>として存在しています。<BR><BR>

			　まず Borland のサイトで <FONT COLOR="#770000">Turbo Debugger 5.5</FONT> という Borland C++ と同じく無償
			配布されているソフトを以下のページの手順に従ってダウンロードします。(ユーザー登録が必要です)<BR><BR>

			<A HREF="http://www.borland.co.jp/cppbuilder/freecompiler/turbodebugger.html">http://www.borland.co.jp/cppbuilder/freecompiler/turbodebugger.html</A><BR><BR>

			　ダウンロードしたファイルを展開しようとするとパスワードを訊かれる以外に
			展開するフォルダを聞いてきますので、Borland C++ Compiler 5.5 をインストール
			したフォルダを指定して下さい。<BR><BR>

			　問題なく展開された場合は Borland C++ Compiler 5.5 をインストールしたフォルダの
			中の『bin』というフォルダの中に TD32.exe, TD32INST.exe, TD32HELP.TDH という
			ファイルが追加されます。<BR><BR>

			　次に <FONT COLOR="#770000">BCC Developer</FONT> のメニューから<FONT COLOR="#770000">『ツール』→『環境設定』</FONT>を開き
			<FONT COLOR="#770000">『コンパイラ設定』タグ</FONT>の<FONT COLOR="#770000">『デバッガ』</FONT>の項目に先ほどインストールした
			<FONT COLOR="#770000">Turbo Debugger 5.5</FONT> を指定します、Borland C++ も Turbo Debugger も標準どおりの設定でインストール
			していたら C:\borland\bcc55\Bin\TD32.EXE 辺りになるはずです。<BR>
			　選択が終了したら<FONT COLOR="#770000">『設定』</FONT>ボタンを押して環境設定ウインドウを閉じます。<BR><BR>

			　次に適当にデバッグしたいプロジェクトを開き、メニューから
			<FONT COLOR="#770000">『実行』→『デバッグ』</FONT>を選んで<FONT COLOR="#770000">デバッグモード</FONT>で起動します。<BR><BR>

			　すると、<FONT COLOR="#770000">Turbo Debugger</FONT> が起動します。<BR><BR>

			　なお、<FONT COLOR="#770000">Windows2000</FONT> と <FONT COLOR="#770000">WindowsXP</FONT> ではもしかしたら <FONT COLOR="#770000">Turbo Debugger</FONT> 上でのマウスの操作
			が出来ないかもしれません。その場合は以下のことを試してください。<BR><BR>

			<FONT COLOR="#006600">
			〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜<BR>
			　Turbo Debugger 5.5 の<FONT COLOR="#770000">システムバーで右クリック</FONT>をして、メニューから
			<FONT COLOR="#770000">『プロパティ』</FONT>を選んでプロパティダイアログを表示してください。<BR>
			　開いたら<FONT COLOR="#770000">『オプション』タグ</FONT>を選び、その中の<FONT COLOR="#770000">『編集オプション』</FONT>の中の<FONT COLOR="#770000">『簡易
			編集モード』</FONT>にチェックが入っていたら<FONT COLOR="#770000">チェックを外して『ＯＫ』</FONT>を押して下さい。<BR>
			　<FONT COLOR="#770000">『ＯＫ』</FONT>を押したときに<FONT COLOR="#770000">『現在のウインドウだけに適応する』</FONT>のか<FONT COLOR="#770000">『同じタイトルの
			ウインドウに適応する』</FONT>のか聞いてきますが、これは<FONT COLOR="#770000">『同じタイトルのウインドウに適応する』</FONT>
			を選択して<FONT COLOR="#770000">『ＯＫ』</FONT>を押してください。<BR><BR>

			　これでマウスが効くようになると思います。<BR>
			〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜〜<BR><BR>
			</FONT>

			　さて、使い方です。<BR>
			　私も殆ど知らないので最低限の使い方だけをご説明します。<BR><BR>

			　まず起動すると、初っ端からプログラムが止まっています。<BR><BR>

			　メニューの<FONT COLOR="#770000">『Run』→『Run』</FONT>を指定すると<FONT COLOR="#770000">(又はＦ９キーを押すと)</FONT>普通に実行が始まります。<BR>
			　メニューの<FONT COLOR="#770000">『Run』→『Step over』(又はＦ８)</FONT>で一行だけ実行します、実行する一行の中で関数が
			呼ばれていても関数の中はトレースせずに、次の行に移ります。<BR>
			　メニューの<FONT COLOR="#770000">『Run』→『Trace into』(又はＦ７)</FONT>で同じく一行だけ実行しますが、実行する一行
			の中で関数が呼ばれている場合は関数の中の最初の行に移ります。<BR><BR>

			　止まっている関数で宣言されているローカル変数を表示したい場合はメニューの<FONT COLOR="#770000">『View』→『Valiables』</FONT>を
			選びます。するとプログラム中の全関数名が上部に、関数内で使用している変数の一覧が
			下部に表示されたウインドウが開きます。<BR>
			　グローバル変数(又は配列・構造体)を表示したい場合はメニューの<FONT COLOR="#770000">『Data』→『Add watch...』</FONT>
			を選び、グローバル変数名を入力して<FONT COLOR="#770000">『OK』</FONT>を選びます。すると Turbo Debugger 画面の下部に
			ある<FONT COLOR="#770000">『Watches』</FONT>というウインドウの中に入力した変数の状態が表示されます。表示する行を
			増やしたい場合は、ウインドウ枠の上部を左クリックで掴んで上に移動した後、右下の矢印以外の
			部分を引っ張ります。<FONT COLOR="#770000">『Watches』</FONT>ウインドウが見当たらない時はメニューの<FONT COLOR="#770000">『View』→『Watches』</FONT>
			を選びます。<BR><BR>

			　ブレイクポイント(何処でプログラムを止めるか、の指定)を設定するにはメニューの
			<FONT COLOR="#770000">『Breakpoints』→『Toggle』(又はＦ２)</FONT>を選びます。(無効にしたい時も無効にしたい
			ブレイクポイントが設定されている行で<FONT COLOR="#770000">『Breakpoints』→『Toggle』(又はＦ２)</FONT>を選びます)
			(尚、残念ながら Visual C++ のようにプログラムの編集画面からブレイクポイントを設定する事は出来ません)<BR>
			　設定したブレイクポイントを全て無効化したい場合は<FONT COLOR="#770000">『Breakpoints』→『Delete all』</FONT>を選びます。<BR>
			　ブレイクポイントを設定したい行が別のファイルである場合はメニューの<FONT COLOR="#770000">『View』→
			『Module...』(又はＦ３)</FONT>を選んでブレイクポイントを設定したい行があるファイルを開きます。<BR><BR>

			　ブレイクしたところまでどの関数を辿ってきたかを知りたいときはメニューから<FONT COLOR="#770000">『View』→
			『Stack』</FONT>を選び、辿ってきた関数の一覧が表示されているコールスタックウインドウを開きます。<BR>
			　どの行でその関数が呼ばれたのかを知りたい場合は、コールスタックウインドウ
			からその関数を選び、Enter キーを押します。するとその関数が呼ばれた行まで飛ぶ事が
			出来ます。(別ファイルだった場合はそのファイルを自動的に開きます)<BR><BR>


			　BCC Developer のアウトプットウインドウに相当するウインドウはメニューの<FONT COLOR="#770000">『View』→『Log』</FONT>
			を選ぶと開く事が出来ます。<BR><BR>

			　デバッグを終了したい場合はメニューの<FONT COLOR="#770000">『File』→『Quit』</FONT>を選びます。<BR><BR>

			　私が知っている事は大体この位です。<BR>
			　残りの機能は皆さんが見つけてください。(^^;<BR><BR><BR><BR>



			
			
			　<FONT COLOR="#007712"><A NAME="T9">ソフトのタイトルを変更する</A></FONT><BR><BR>
			  
			  ＤＸライブラリのソフトを起動すると、標準ではウインドウのシステムバーに表示される
			タイトルは『DxLib』になっています。これを変更するには関数リファレンスの『マイナー関数』
			に分類されている <A HREF="dxfunc.html#R15N13">SetWindowText</A> という関数を使用します。
			　同じくソフトを起動すると必ず作成される AppLog.txt を作成しないようにするには
			<A HREF="dxfunc.html#R15N14">SetOutApplicationLogValidFlag</A> という関数を使用します。<BR><BR><BR><BR>




			　<FONT COLOR="#007712"><A NAME="T11">アーカイブ機能を使ってファイルを一つに纏める</A></FONT><BR><BR>

			　ゲーム中で使う<FONT COLOR="#770000">画像</FONT>や<FONT COLOR="#770000">音</FONT>は、出来れば<FONT COLOR="#770000">ゲーム画面以外では見れないようにしたい</FONT>ものですよね。<BR>
			あと、ゲームで使うファイルも出来れば少なく済ませたいものです。<BR><BR>

			　そんな時に思いつくのが <FONT COLOR="#770000">Lzh</FONT> や <FONT COLOR="#770000">Zip</FONT> 等の、ファイルを圧縮すると共に複数のファイルを一つに纏めてしまうアーカイバですが、
			ＤＸライブラリでは Lzh や Zip は使えません。<BR><BR>
			
			　ですが、ＤＸライブラリには圧縮する機能が無いだけの似たようなアーカイブファイル<FONT COLOR="#770000">『ＤＸアーカイブ』</FONT>
			(そのまんまだ)を簡単に使うための機能がついています。<BR><BR>

			　以下は<FONT COLOR="#770000">ＤＸライブラリの圧縮ファイルの中</FONT>にある、<FONT COLOR="#770000">『Tool\DXArchive\readme.txt』</FONT>の内容をそのまま貼り付けたものです。<BR><BR>
<PRE>
--------------------------------
-
-　ＤＸアーカイブ説明書
-
-　Version 1.01
-
--------------------------------

<FONT COLOR="#007700">・概要</FONT>

　　　<FONT COLOR="#770000">lzh</FONT>ファイル や <FONT COLOR="#770000">zip</FONT>ファイルのように、<FONT COLOR="#770000">複数のファイルを
　　一つのファイルに纏めるソフト</FONT>です。(ただ纏めるだけなので
　　lzh や zip の様に容量は小さくなりませんが)

　　　作成したアーカイブファイルはＤＸライブラリでも読み込めます。


<FONT COLOR="#007700">・ファイル説明</FONT>

　　<FONT COLOR="#770000">DxaEncode.exe</FONT>　　　アーカイブファイルを作成するソフトです
　　<FONT COLOR="#770000">DxaDecode.exe</FONT>　　　アーカイブファイルを元に戻すソフトです(多分あんまり使いません)

　　<FONT COLOR="#770000">Source</FONT>
　　　　<FONT COLOR="#770000">DxaEncode.exe</FONT> や <FONT COLOR="#770000">DxaDecode.exe</FONT> のプログラムソースが入っています。
　　　　(整理していないので汚いです・・・)


<FONT COLOR="#007700">・使い方</FONT>


　<FONT COLOR="#007700">・アーカイブファイルの作成方法と使用方法</FONT>

　　　１．<FONT COLOR="#770000">中身を一つに纏めたいフォルダ</FONT>を <FONT COLOR="#770000">DxaEncode.exe</FONT> に<FONT COLOR="#770000">ドラッグ＆ドロップ</FONT>します
　　　２．<FONT COLOR="#770000">フォルダ名と同じ名前のＤＸアーカイブファイル</FONT>が、<FONT COLOR="#770000">拡張子 dxa</FONT> で作成されます
　　　３．ＤＸライブラリは<FONT COLOR="#770000">ＤＸアーカイブファイルをフォルダとみなす</FONT>ので、例えば

　　　<FONT COLOR="#770000">Image</FONT> という<FONT COLOR="#770000">フォルダ</FONT>から画像を読み込んでいたとします。

　　　　<FONT COLOR="#007700"><ファイル構成></FONT>
　　　　実行ファイル
　　　　<FONT COLOR="#770000">Imageフォルダ</FONT>(中にGraph1.bmpがある)

　　　　GraphHandle = LoadGraph( "<FONT COLOR="#770000">Image</FONT>\\Graph1.bmp" ) ;


　　　この <FONT COLOR="#770000">Image フォルダ</FONT>を <FONT COLOR="#770000">DxaEncode.exe</FONT> に<FONT COLOR="#770000">ドラッグ＆ドロップ</FONT>して <FONT COLOR="#770000">Image.dxa</FONT> を
　　作成し、<FONT COLOR="#770000">Image.dxa</FONT> を <FONT COLOR="#770000">Image フォルダ</FONT>の<FONT COLOR="#770000">代わりに使う</FONT>ことが出来ます。

　　　　<FONT COLOR="#007700"><ファイル構成></FONT>
　　　　実行ファイル
　　　　<FONT COLOR="#770000">Image.dxa</FONT>

　　　　GraphHandle = LoadGraph( "<FONT COLOR="#770000">Image</FONT>\\Graph1.bmp" ) ;


　　　因みに、<FONT COLOR="#770000">ＤＸアーカイブファイル</FONT>の<FONT COLOR="#770000">名前を変更</FONT>すると<FONT COLOR="#770000">指定すべきフォルダ名</FONT>も変わります。

　　　　<FONT COLOR="#007700"><ファイル構成></FONT>
　　　　実行ファイル
　　　　<FONT COLOR="#770000">ImageGraphics.dxa</FONT>

　　　　GraphHandle = LoadGraph( "<FONT COLOR="#770000">ImageGraphics</FONT>\\Graph1.bmp" ) ;



　<FONT COLOR="#007700">・アーカイブファイルの展開方法</FONT>

　　　１．ＤＸアーカイブファイルを <FONT COLOR="#770000">DxaDecode.exe</FONT> にドラッグ＆ドロップします
　　　２．ＤＸアーカイブファイルがある位置と同じフォルダにＤＸアーカイブファイルの中身が展開されます

</PRE>
<BR>
			　デコーダがあるので暗号化の意味はちょっと薄いかもしれませんが、何もしないよりはずっとマシな筈です。<BR><BR>
			　尚、<FONT COLOR="#770000">『拡張子が dxa のままは嫌』</FONT>という方や、<FONT COLOR="#770000">『常に dxa ファイルをフォルダに見なされると都合が悪い』</FONT>
			という方は、<A HREF="dxfunc.html#R15N30">SetUseDXArchiveFlag関数</A> や <A HREF="dxfunc.html#R15N30">SetDXArchiveExtension関数</A>
			をお使いください。<BR><BR>

			　また、この<FONT COLOR="#770000">ＤＸアーカイブ</FONT>に含まれた、<FONT COLOR="#770000">ＤＸライブラリの機能以外で使用するファイル</FONT>にアクセスする場合は以下の関数をお使いください。
			(<FONT COLOR="#770000">ＤＸアーカイブ</FONT>が<FONT COLOR="#770000">無かった場合</FONT>は勝手に<FONT COLOR="#770000">通常のファイルを開く</FONT>ので、<FONT COLOR="#770000">ＤＸアーカイブ</FONT>を<FONT COLOR="#770000">使う場合</FONT>と<FONT COLOR="#770000">使わない場合</FONT>で関数を使い分ける必要は<FONT COLOR="#770000">ありません</FONT>)<BR><BR>

		　　<A HREF="dxfunc.html#R19N1">FileRead_open</A>　ファイルを開く<BR>
		　　<A HREF="dxfunc.html#R19N2">FileRead_size</A>　ファイルのサイズを得る<BR>
		　　<A HREF="dxfunc.html#R19N3">FileRead_close</A>　ファイルを閉じる<BR>
		　　<A HREF="dxfunc.html#R19N4">FileRead_tell</A>　ファイルポインタの位置を得る<BR>
		　　<A HREF="dxfunc.html#R19N5">FileRead_seek</A>　ファイルポインタの位置を変更する<BR>
		　　<A HREF="dxfunc.html#R19N6">FileRead_read</A>　ファイルからデータを読み込む<BR>
		　　<A HREF="dxfunc.html#R19N7">FileRead_eof</A>　ファイルの終端かどうかを調べる<BR>
		　　<A HREF="dxfunc.html#R19N8">FileRead_gets</A>　ファイルから一行読み出す<BR>
		　　<A HREF="dxfunc.html#R19N9">FileRead_getc</A>　ファイルから一文字読み出す<BR>

			<BR><BR><BR><BR>


			  

			　<FONT COLOR="#007712"><A NAME="T1">数値をグラフィックで表示する</A></FONT><BR><BR>

			　数値表示や文字列表示は DrawString で行うわけですが、ゲーム中のスコア表示などは１色の
			標準フォント数字ではなく独自に用意した数字グラフィックを使いたいものです。<BR>
			　そこでまず数字グラフィックを用意します、数字グラフィックは左から０から９までの数字
			が等間隔で描かれた横長のグラフィックです。ペイントでもなんでも良いので用意してください。
			(ＤＸライブラリについて来る『Sample実行用フォルダ』フォルダに『Num.bmp』というサンプルのグラフィックが
			ありますのでそちらを使って頂いてもＯＫです)<BR>
			　次にそのグラフィックを LoadDivGraph関数で分割読み込みをします。一つのＢＭＰファイルを
			いくつかのグラフィックに分割してロードするときに使う関数です。<BR>
			　えー、あとは以下のプログラムを参考にしてください。(無責任)
<FONT COLOR="#000066"><PRE>
#include "DxLib.h"

#define WIDTH  24	<FONT COLOR="#006600">// 数字グラフィック横幅</FONT>
#define HEIGHT 24	<FONT COLOR="#006600">// 数字グラフィック高さ</FONT>

int NumHandle[ 10 ];	<FONT COLOR="#006600">// 数字グラフィックの識別番号を保存する配列</FONT>

<FONT COLOR="#006600">// 数値をグラフィック表示する関数</FONT>
void NumDraw( int Num ) ;

<FONT COLOR="#006600">// WinMain関数</FONT>
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
				 LPSTR lpCmdLine, int nCmdShow )
{
	if( <A HREF="dxfunc.html#R1N1">DxLib_Init</A>() == -1 )	<FONT COLOR="#006600">// ＤＸライブラリ初期化処理</FONT>
	{
		 return -1;		<FONT COLOR="#006600">// エラーが起きたら直ちに終了</FONT>
	}

<FONT COLOR="#006600">	// 数字グラフィックを分割読みこみ
	// 分割数は全部で10こ、１列当たり10個の分割数でそれが１行だけあるので
	// 以下のような記述になります。</FONT>
	<A HREF="dxfunc.html#R3N3">LoadDivGraph</A>( "Num.bmp" , 10 , 10 , 1 , WIDTH , HEIGHT , NumHandle ) ;

	<FONT COLOR="#006600">// 数値２５６をグラフィック数字で表示</FONT>
	NumDraw( 256 ) ;

	<FONT COLOR="#006600">// キー入力待ち</FONT>
	<A HREF="dxfunc.html#R6N3">WaitKey</A>() ;

	<A HREF="dxfunc.html#R1N2">DxLib_End</A>() ;			<FONT COLOR="#006600">// ＤＸライブラリ使用の終了処理</FONT>

	return 0 ;			<FONT COLOR="#006600">// ソフトの終了</FONT>
}

<FONT COLOR="#006600">// 数値をグラフィック表示する関数</FONT>
void NumDraw( int Num )
{
	int i , BeamWidth , x ;

	<FONT COLOR="#006600">// Numが十進数で何桁になるか調べる</FONT>
	BeamWidth = 0 ;
	for( i = 10 ; Num >= i ; i *= 10 ) BeamWidth ++ ;

	<FONT COLOR="#006600">// 画面左上にグラフィックで描画
	// x は数字グラフィックを描く矩形の左端の座標です</FONT>
	x = BeamWidth * WIDTH ;	
	for( i = 0 ; i <= BeamWidth ; i ++ )
	{
		<FONT COLOR="#006600">// 数字の描画(透過色あり)
		// NumHandle 配列には要素番号０には『０』のグラフィック識別番号が
		// １には『１』のグラフィック識別番号が入っているので、
		// DrawGraph( 0 , 0 , NumHandle[ 0 ] , TRUE ) ; とすれば
		// 『０』のグラフィックを描画できることをお忘れなく</FONT>
		<A HREF="dxfunc.html#R3N7">DrawGraph</A>( x , 0 , NumHandle[ Num % 10 ], TRUE ) ;

		<FONT COLOR="#006600">// 描画Ｘ座標を移動</FONT>
		x -= WIDTH ;

		<FONT COLOR="#006600">// １番下の桁が描画し終わったので一桁下げる</FONT>
		Num /= 10 ;
	}
}
</PRE></FONT>
<BR><BR><BR><BR>




			　<FONT COLOR="#007712"><A NAME="T2">使えるＣ言語標準関数集</A></FONT><BR><BR>

			　コンソールアプリケーションではない Windows環境でのプログラムでも使えるＣ言語標準関数は
			沢山あります、ですがそれらの関数はあまり公には広まっていません。それはおそらくVisualC++に
			本の形での標準関数リファレンスがないからだと思いますが、とにかくあまりVisualC++のヘルプから
			標準関数の項目をめくる人はいないと思います。<BR><BR>

			　とりあえずヘルプ中のどの場所に標準関数のことが書かれているか以下にしめします。<BR><BR>

			　メニュ−の<FONT COLOR="#770000">『ヘルプ』→『目次』</FONT>でヘルプを開く。<BR>
			　開いたら左の目次タグから<FONT COLOR="#770000">『ＭＳＤＮライブラリ Visual Studio 6.0』→『Visual C++ ドキュメント』
			→『Visual C++ ユーザーズガイド』→『Visual C++ プログラマーズガイド』→『ランタイムライブラリ
			リファレンス』→『カテゴリ別ランタイムルーチン』</FONT>を開いていきます。この<FONT COLOR="#770000">『カテゴリ別ランタイムルーチン』</FONT>
			の項目が主にＣ言語標準関数の説明となります。(なんでこんなにわかりにくいところにあるんだろう…)<BR><BR>

			　次にとりあえず私が使えると思うＣ言語標準関数を紹介します。詳しい説明はVisualC++のヘルプから検索して
			見てください。<BR><BR><BR>
			<TABLE ALIGN="CENTER" WIDTH=650  CELLSPACING=0 CELLPADDING=0 >
				<TR><TD COLSPAN=2><FONT COLOR="#008811">プロセス管理関係</FONT><BR><BR></TD></TR>

				<TR><TD COLSPAN=2><FONT COLOR="#880000">( stdlib.h )</FONT></TD></TR>
				<TR><TD VALIGN="TOP">　exit</TD><TD>　ソフトを終了する<BR><BR><BR></TD></TR>

				<TR><TD OLSPAN=2><FONT COLOR="#008811"><FONT COLOR="#008811">文字列操作<BR><BR></FONT>

				<TR><TD COLSPAN=2><FONT COLOR="#880000">( string.h )</FONT></TD></TR>
				<TR><TD>　strcpy</TD><TD>　文字列のコピー</TD></TR>
				<TR><TD>　strcat</TD><TD>　文字列の追加</TD></TR>
				<TR><TD>　strcmp</TD><TD>　文字列の比較</TD></TR>
				<TR><TD>　strchr</TD><TD>　文字の検索</TD></TR>
				<TR><TD VALIGN="TOP">　sprintf</TD><TD>　書式付き文字列出力を行う<BR><BR><BR></TD></TR>


				<TR><TD COLSPAN=2><FONT COLOR="#008811"><FONT COLOR="#008811">ファイル操作</FONT><BR><BR></TD></TR>

				<TR><TD COLSPAN=2>　<FONT COLOR="#880000">( stdio.h )</FONT></TD></TR>
				<TR><TD>　fopen</TD><TD>　ファイルを開く</TD></TR>
				<TR><TD>　fclose</TD><TD>　ファイルを閉じる</TD></TR>
				<TR><TD>　fwrite</TD><TD>　ファイルにデータを書き出す</TD></TR>
				<TR><TD>　fread</TD><TD>　ファイルのデータを読み出す</TD></TR>
				<TR><TD VALIGN="TOP">　fseek</TD><TD>　ファイルのデータ操作位置を変更する<BR><BR></TD></TR>

				<TR><TD COLSPAN=2>　<FONT COLOR="#880000">( direct.h )</FONT></TD></TR>
				<TR><TD>　_chdir</TD><TD>　カレントディレクトリ(フォルダ)を変更する</TD></TR>
				<TR><TD>　_getcwd</TD><TD>　現在のカレント ディレクトリ(フォルダ)を取得する。</TD></TR>
				<TR><TD>　_mkdir</TD><TD>　ディレクトリを新規作成する。</TD></TR>
				<TR><TD>　_rmdir</TD><TD>　ディレクトリを削除する。</TD></TR>
				<TR><TD VALIGN="TOP">　_searchenv</TD><TD>　指定されたパスで指定されたファイルを検索する。<BR><BR></TD></TR>
				<TR><TD COLSPAN=2>※…関数の前に『_』がついているのは使用を推奨されていない関数ですが、
				推奨されていないだけで問題なく使えるので使いましょう。<BR>
				例( _getcwd は WindowsAPIの GetCurrentDirectoryの使用を進められている) <BR><BR><BR></TD></TR>

				<TR><TD COLSPAN=2><FONT COLOR="#008811">メモリ関係</FONT><BR><BR></TD></TR>

				<TR><TD COLSPAN=2>　<FONT COLOR="#880000">( malloc.h と stdlib.h )</FONT></TD></TR>
				<TR><TD>　malloc</TD><TD>　メモリを確保する</TD></TR>
				<TR><TD VALIGN="TOP">　free</TD><TD>　確保したメモリを解放する<BR><BR></TD></TR>

				<TR><TD COLSPAN=2>　<FONT COLOR="#880000">( string.h )</FONT></TD></TR>
				<TR><TD>　memcpy</TD><TD>　メモリをコピーする</TD></TR>
				<TR><TD>　memset</TD><TD>　１バイトの値で指定メモリ領域を埋める</TD></TR>
				<TR><TD VALIGN="TOP">　memmove</TD><TD>　指定領域のメモリを別のアドレスへ移動する<BR><BR><BR></TD></TR>


				<TR><TD COLSPAN=2><FONT COLOR="#008811">数学</FONT><BR><BR>

				<TR><TD COLSPAN=2>　<FONT COLOR="#880000">( math.h )</FONT></TD></TR>
				<TR><TD>　abs</TD><TD>　絶対値を得る</TD></TR>
				<TR><TD>　fabs</TD><TD>　double型などの絶対値を得る</TD></TR>
				<TR><TD>　fmod</TD><TD>　double型での商の余りを得る</TD></TR>
				<TR><TD>　pow</TD><TD>　べき乗する(２乗、３乗など)</TD></TR>
				<TR><TD VALIGN="TOP">　sqrt</TD><TD>　平方根を得る<BR><BR></TD></TR>

				<TR><TD>　sin</TD><TD>　サインを計算する</TD></TR>
				<TR><TD>　cos</TD><TD>　コサインを計算する</TD></TR>
				<TR><TD>　tan</TD><TD>　タンジェントを計算する</TD></TR>
				<TR><TD>　asin</TD><TD>　アークサインを計算する</TD></TR>
				<TR><TD>　acos</TD><TD>　アークコサインを計算する</TD></TR>
				<TR><TD VALIGN="TOP">　atan</TD><TD>　アークタンジェントを計算する<BR><BR></TD></TR>

				<TR><TD COLSPAN=2>　<FONT COLOR="#880000">( stdlib.h )</FONT></TD></TR>
				<TR><TD>　rand</TD><TD>　乱数を得る</TD></TR>
				<TR><TD VALIGN="TOP">　srand</TD><TD>　乱数ジェネレータを初期化する<BR><BR></TD></TR>

			</TABLE>

			<BR><BR>

			　標準関数を使うことはすなわちＯＳに依存する部分を全く考慮しないことになるので、特にファイル関係の
			標準関数の使用は望ましくないとされるのが一般ですが、ゲーム中のデータのセーブなどの単純で一時的な
			ファイルの操作では全く問題にはなりません。
			<BR><BR><BR><BR>
			
			
			

			　<FONT COLOR="#007712"><A NAME="M1">ソフトが完成したらDebugビルドではなくReleaseビルドを行い処理速度の向上を図る</A></FONT><BR><BR>

			　ソフトの開発中はおそらくデバッグスタート(Ｆ５で実行)をしていると思いますが、いえ
			デバッグ機能を使っていなくてもデバッグスタートが出来る実行可能ファイルとしてビルドされますが、
			こうして出来る実行可能ファイルはデバッグ用の情報を多く含むのでその情報をいれない時に比べて
			２００ＫＢほどファイルの容量が増えてしまいます。(処理速度も落ちます)<BR>
			　そこで、ソフトが完成したらリリースビルドという、デバッグ情報を含まない実行可能ファイルを
			ビルドすることで容量の縮小及び処理速度の向上をすることが出来ます。<BR>
			　方法はまずメニューの<FONT COLOR="#770000">『ビルド』→『アクティブな構成の設定』</FONT>を開きます、すると<FONT COLOR="#770000">『〜〜Debug』</FONT>と
			<FONT COLOR="#770000">『〜〜Release</FONT>』がリストの中に表示されていて、おそらく<FONT COLOR="#770000">『〜〜Debug』</FONT>のほうが選択されていると
			思いますので、ここでもう一つの<FONT COLOR="#770000">『〜〜Release』</FONT>の方を選択してＯＫボタンを押します。これでもう一度
			ビルドするとリリースビルドされた実行可能ファイルが出来ます。<BR><BR><BR><BR>



			　<FONT COLOR="#007712"><A NAME="M2">自作ソフトにオリジナルアイコンを付ける</A></FONT><BR><BR>

			　自作ソフトの実行可能ファイルのアイコンを独自で作ったアイコンにしたい、という場合の方法です。
			完全に私が導き出した方法ですのでもっと良い方法があると思うのですが、調べるのが面倒ですし私は
			この方法で満足しているので、もし<FONT COLOR="#770000">『これの方が楽じゃん』</FONT>というご意見のある方はどうかご一報下さい。<BR><BR><BR>


			<FONT COLOR="#000077">ＢｏｒｌａｎｄＣ＋＋　Ｃｏｍｐｉｌｅｒ　５．５ 　の場合</FONT><BR><BR>

			　まず<FONT COLOR="#770000">縦横３２ドット、２５６色(８ビット)</FONT>のアイコンファイル(<FONT COLOR="#770000">拡張子『ico』</FONT>)を作成し、<FONT COLOR="#770000">BCC Developer</FONT> のプロジェクトファイル(<FONT COLOR="#770000">拡張子『bdp』</FONT>)が
			あるフォルダに保存します。（<FONT COLOR="#770000">『アイコン用ユーティリティ』</FONT>等でWEB検索するとアイコンを作成するためのソフトが色々見つかります)<BR>
			　次に同様にプロジェクトファイルがあるフォルダに<FONT COLOR="#770000">『Resource.rc』</FONT>というファイルを作成し、
			（エクスプローラのフォルダオプションで<FONT COLOR="#770000">『登録されている拡張子は表示しない』</FONT>のチェックを外しておいてください)
			そのファイルをメモ帳等のテキストエディタで中身に次のように入力して保存して下さい。<BR><BR>
			<FONT COLOR="#770000">MAINICON ICON "<FONT COLOR="#000077">ここにアイコンファイルのファイル名</FONT>"<BR></FONT><BR>
			　次に プロジェクトを BCC Developer で開き、<FONT COLOR="#770000">『プロジェクト』→『プロジェクトの設定』</FONT>で
			プロジェクトの設定ダイアログを表示し、その中の<FONT COLOR="#770000">『リソーススクリプト』</FONT>タグの中の
			<FONT COLOR="#770000">『リソーススクリプトファイル名』</FONT>の欄に <FONT COLOR="#770000">Resource.rc</FONT> と
			記述した上で<FONT COLOR="#770000">『設定』</FONT>ボタンを押してダイアログを閉じて下さい。<BR>
			　これで、次にビルドした時には作成される実行可能ファイルのアイコンがオリジナルのアイコンになります。<BR><BR><BR>


			<FONT COLOR="#000077">VisualC++ 2005 Express Edition の場合</FONT><BR><BR>

			　VisualC++ 2005 Express Edition(以後VisualC++2005EE)でアイコンを付ける方法は、
			まず<FONT COLOR="#770000">縦横３２ドット、２５６色(８ビット)</FONT>のアイコンファイル(<FONT COLOR="#770000">拡張子『ico』</FONT>)を作成し、<FONT COLOR="#770000">VisualC++2005EE</FONT> のプロジェクトファイル(<FONT COLOR="#770000">拡張子『sln』</FONT>)が
			あるフォルダに保存します。（<FONT COLOR="#770000">『アイコン用ユーティリティ』</FONT>等でWEB検索するとアイコンを作成するためのソフトが色々見つかります)<BR>
			　次に同様にプロジェクトファイルがあるフォルダに<FONT COLOR="#770000">『Resource.rc』</FONT>というファイルを作成し、
			（エクスプローラのフォルダオプションで<FONT COLOR="#770000">『登録されている拡張子は表示しない』</FONT>のチェックを外しておいてください)
			そのファイルをメモ帳等のテキストエディタで中身に次のように入力して保存して下さい。<BR><BR>
			<FONT COLOR="#770000">MAINICON ICON "<FONT COLOR="#000077">ここにアイコンファイルのファイル名</FONT>"<BR></FONT><BR>
			　次に プロジェクトを VisualC++2005EE で開き、<FONT COLOR="#770000">『プロジェクト』→『既存項目の追加』</FONT>で
			追加ファイル選択ダイアログを表示して、先ほど作成した<FONT COLOR="#770000">『Resource.rc』</FONT>をプロジェクトに追加します。<BR>
			　これで、次にビルドした時には作成される実行可能ファイルのアイコンがオリジナルのアイコンになります。<BR><BR><BR>


			<FONT COLOR="#000077">ＶｉｓｕａｌＣ＋＋．ＮＥＴ　の場合</FONT><BR><BR>

			　まず<FONT COLOR="#770000">縦横３２ドット、２５６色(８ビット)</FONT>のアイコン用ビットマップを作成します。(どんな
			グラフィック作成ツールでも大丈夫です)このとき<FONT COLOR="#770000">真っ白の色が透過色(透き通る色)になります</FONT>ので
			覚えておいてください。<BR>
			　次にVisualC++.NETのメニューの<FONT COLOR="#770000">『開く』→『ファイル』</FONT>を選び、<FONT COLOR="#770000">『ファイルの種類』</FONT>を<FONT COLOR="#770000">『すべてのファイル』</FONT>に変更し、
			アイコン用ビットマップファイルを開きます。<BR>
			　開いたら次にメニューの<FONT COLOR="#770000">『イメージ』→『パレットの保存』</FONT>で適当な場所にパレットファイルを保存します。<BR>
			　更にそのまま次にメニューの<FONT COLOR="#770000">『編集』→『コピー』</FONT>を選びグラフィックデータをクリップボードに退避します。<BR>
			ここまでの作業が終了したらビットマップファイルは閉じてしまって結構です。<BR>
			　次にメニューの<FONT COLOR="#770000">『プロジェクト』→『リソースの追加』</FONT>を開き、その中の<FONT COLOR="#770000">『Icon』</FONT>をダブルクリックし、
			アイコンリソースを追加します。<BR>
			　次にメニューから<FONT COLOR="#770000">『イメージ』→『パレットの読みこみ』</FONT>で先程保存したパレットファイルを読みこみます。<BR>
			　次にメニューの<FONT COLOR="#770000">『編集』→『貼りつけ』</FONT>でクリップボードに先ほど退避したアイコン用
			グラフィックを貼りつけます。
			　最後に<FONT COLOR="#770000">『ファイル』→『すべて保存』</FONT>を実行してアイコンの追加作業は完了です。<BR>
			　これで再びビルドすれば実効可能ファイルのアイコンがオリジナルのアイコンになります。<BR><BR><BR>

			<FONT COLOR="#000077">ＶｉｓｕａｌＣ＋＋６．０　の場合</FONT><BR><BR>

			　まず<FONT COLOR="#770000">縦横３２ドット、２５６色(８ビット)</FONT>のアイコン用ビットマップを作成します。(どんな
			グラフィック作成ツールでも大丈夫です)このとき<FONT COLOR="#770000">真っ白の色が透過色(透き通る色)になります</FONT>ので
			覚えておいてください。<BR>
			　次にVisualC++のメニューの<FONT COLOR="#770000">『開く』</FONT>を選び、<FONT COLOR="#770000">『ファイルの種類』</FONT>を<FONT COLOR="#770000">『すべてのファイル』</FONT>に変更し、
			アイコン用ビットマップファイルを開きます。<BR>
			　開いたら次にメニューの<FONT COLOR="#770000">『イメージ』→『パレットの保存』</FONT>で適当な場所にパレットファイルを保存します。<BR>
			更にそのまま次にメニューの<FONT COLOR="#770000">『編集』→『コピー』</FONT>を選びグラフィックデータをクリップボードに退避します。<BR>
			ここまでの作業が終了したらビットマップファイルは閉じてしまって結構です。<BR>
			　次にメニューの<FONT COLOR="#770000">『挿入』→『リソース』</FONT>を開き、その中の<FONT COLOR="#770000">『Icon』</FONT>をダブルクリックし、リソース
			ウインドウを開きます。次に、開いたアイコンエディットウインドウの<FONT COLOR="#770000">『標準(32x32)』</FONT>とかかれている部分の
			すぐ右にあるボタンを押し、<FONT COLOR="#770000">『アイコンイメージの新規作成』</FONT>ウインドウを開き、リストの中から<FONT COLOR="#770000">『32x32.256色』</FONT>
			を選びＯＫを押します。<BR>
			　そして今度はメニューの<FONT COLOR="#770000">『編集』→『貼りつけ』</FONT>でクリップボードに先ほど退避したアイコン用
			グラフィックを貼りつけます。次にメニューから<FONT COLOR="#770000">『イメージ』→『パレットの読みこみ』</FONT>で
			こちらも先ほど保存したパレットファイルを読みこみアイコン作成作業は完了です。<BR>
			　次に<FONT COLOR="#770000">『ファイル』→『すべて保存』</FONT>を選択するとどこにリソーススクリプトファイルを保存するか
			聞いてきますのでどこかに保存してください。<BR>
			　そして最後に<FONT COLOR="#770000">『プロジェクト』→『プロジェクトへ追加』→『ファイル』</FONT>を選択し、保存したリソーススクリプトファイル
			(Script.rc等)をプロジェクトに追加します。<BR>
			　これで再びビルドすれば実効可能ファイルのアイコンがオリジナルのアイコンになります。<BR><BR><BR><BR>



			　<FONT COLOR="#007712"><A NAME="M3">ＢＭＰやＷＡＶファイルだとデータが読まれてしまうので…</A></FONT><BR><BR>

			　折角ソフトを作って配布しても、グラフィックデータや音楽データがＢＭＰやＷＡＶファイル形式だと簡単に
			エピローグに流そうとした音楽やグラフィックが見られてしまう。いやそれでも見てしまおうという人は少ない
			とは思いますが、見ようと思えば苦労せずともいつでも見れてしまうのはプレーヤーとしても張り合いがないものです。<BR>
			　そこでどのソフトも大抵は容易には鑑賞できないようにデータを加工するのですが、このライブラリには
			独自のグラフィック形式等はなく、ＢＭＰやＷＡＶ形式しか扱うことが出来ません。(作る予定もありませんし
			なによりそれが私の嫌う『ライブラリ独自の規則』になるのが嫌だからです)<BR>
			　ではどうすれば容易には見れないように出来るでしょうか？<BR>
			　一つ提案します、ファイルの拡張子を<FONT COLOR="#770000">『bmp』</FONT>や<FONT COLOR="#770000">『wav』</FONT>ではなく<FONT COLOR="#770000">『gph』</FONT>や<FONT COLOR="#770000">『snd』</FONT>などの拡張子に変更して
			見たらどうでしょう？<BR>
			　まず<FONT COLOR="#770000">拡張子</FONT>とはファイル名の後ろについている通常三文字のファイル識別文字列のことです。これはWindowsの
			標準の設定ではおそらく見えなくなっていると思いますので、その場合はWindows98の場合しかわかりませんが
			デスクトップの<FONT COLOR="#770000">『スタート』→『設定』→『フォルダオプション』</FONT>を開き<FONT COLOR="#770000">『表示』</FONT>タグの中の<FONT COLOR="#770000">『登録されている
			ファイルの拡張子は表示しない』</FONT>のチェックを外して拡張子を見れるようにしてください。<BR>
			　ではとりあえずビットマップファイルの拡張子<FONT COLOR="#770000">『bmp』</FONT>を<FONT COLOR="#770000">『gph』</FONT>にしてみましょう、こんなもので平気なのか？
			と思われるかもしれません、実際Windows標準グラフィックエディタの<FONT COLOR="#770000">ペイント</FONT>で開くと見れてしまいます。しかし！
			もしあなたがゲームをダウンロードした時、グラフィックデータが<FONT COLOR="#770000">『gph』</FONT>などという聞いたこともないファイル形式
			だった場合<FONT COLOR="#770000">「もしかしたらＢＭＰデータかも」</FONT>などと思って開いてみようと思うでしょうか？おそらくそのようには
			思わないでしょう。因みに拡張子がどうであれ、ライブラリはきちんとロードできます。<BR>
			　この方法だけでほぼ９８％の機密保持の確保はできたと思います。しかしこれでは物足りないという方はもう一つ
			踏みこんだ方法をお教えします。<BR><BR>

			　それは各データファイルの先頭のファイル識別文字列を変更してしまうことです。<BR>
			　具体的な方法はＢＭＰファイルを例に挙げて説明します。<BR>
			　まずVisualC++で<FONT COLOR="#770000">『ファイル』→『開く』</FONT>で、<FONT COLOR="#770000">『用途』</FONT>を<FONT COLOR="#770000">『バイナリ』</FONT>にしてからビットマップファイルを開いて
			みましょう。すると１番左にファイルの<FONT COLOR="#770000">データ番地</FONT>、真中に<FONT COLOR="#770000">データの１６進数値表示</FONT>、１番右に<FONT COLOR="#770000">テキスト文字</FONT>が
			表示されると思います。そこで右のテキスト文字部分の１番左上の２文字を見てみましょう。<BR>
			　<FONT COLOR="#770000">『BM』</FONT>と書かれているはずです。これはビットマップファイル形式のファイルはファイルの先頭２バイトに<FONT COLOR="#770000">『BM』</FONT>という文字を
			あらわす数値が配置されていなければならないという決まりがありまして、その数値とは真中のデータの１６進数値
			表記を見ればわかると思いますが、１６進数で <FONT COLOR="#770000">42</FONT> と <FONT COLOR="#770000">4D</FONT> 、１０進数でいう <FONT COLOR="#770000">66</FONT> と <FONT COLOR="#770000">77</FONT> になっています。この数値を
			別の数値、例えばどちらも０にしてしまって上書き保存してみましょう、おそらくどのエディタでも開くことは
			出来ないはずです。(そのデータを無視するエディタなら開けるでしょうが…)<BR>
			　この方法を使ってすべてのグラフィックデータの先頭２バイトを変更してしまい、グラフィックをロードする前に
			<FONT COLOR="#770000">『BM』</FONT>に直してやる、といった方法を使い、先ほどの方法と２段構えにすればほぼ１００％の機密保持の確保を出来たと
			思います(データ解析のマニアにかかればいちころですが、マニアの目に付くほどのソフトを開発できるようになった
			ころにはもっとよい方法を独自に見つけ出すことが出来ることでしょう)<BR><BR>
			　では<FONT COLOR="#770000">『先頭２バイトを元に戻しロードする』</FONT>という具体的なプログラムを以下にしめします。<BR><BR>

			　例では<FONT COLOR="#770000">test.gph</FONT>という、実はＢＭＰファイル形式のファイルの先頭２バイトを元に戻して読みこみ、その後再び
			先頭２バイトを適当な文字で埋めます。(ファイルの扱いにはＣ標準ライブラリを使います)<BR>
<FONT COLOR="#006600"><PRE>
#include &lt;stdio.h&gt;
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			 LPSTR lpCmdLine, int nCmdShow )
{
	FILE *fp ;
	int GHandle ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;		// エラーが起きたら直ちに終了
	}

	// ファイルを書きこみ専用でオープン
	fp = fopen( "test.gph" , "r+b" ) ;

	// ファイルの先頭２文字を変更
	fwrite( "BM" , sizeof( char ) , 2 , fp ) ;

	// ファイルを閉じる
	fclose( fp ) ;


	// グラフィックを改めて読みこむ
	GHandle = LoadGraph( "test.gph" ) ;


	// ファイルを書きこみ専用でオープン
	fp = fopen( "test.gph" , "r+b" ) ;

	// ファイルの先頭２文字を変更
	fwrite( "  " , sizeof( char ) , 2 , fp ) ;

	// ファイルを閉じる
	fclose( fp ) ;


	// 読みこんだグラフィックを描画
	DrawGraph( 0 , 0 , GHandle , FALSE ) ;

	// キー入力待ち
	WaitKey() ;

	DxLib_End() ;			// ＤＸライブラリ使用の終了処理

	return 0 ;			// ソフトの終了
}
</PRE></FONT>
			　<BR>
			　このプログラムを参考にして実践してみてください。<BR>
			　因みにＷＡＶファイルやＡＶＩファイルは先頭に<FONT COLOR="#770000">『ＲＩＦＦ』</FONT>という文字列があります、こちらも
			同様の方法で開けるのを防ぐことが出来ます。<BR><BR><BR><BR>
	




			　<FONT COLOR="#007712"><A NAME="M5">裏画面のすすめ</A></FONT><BR><BR>

			　ＤＸライブラリを含め、ゲームでは主にグラフィックの描画は裏画面に施し(普通裏画面とは言いませんが…)
			すべての描画処理が終った後に表画面に裏画面の内容をコピー、又は交換することによって描画結果を反映させます。<BR><BR><BR>
	
			　何故このようなことをするのかといいますと、もし表画面、つまりプレイヤーが常に目にしている画面に直接描画処理を
			施した場合、画面が出来あがってゆく過程がプレイヤーの目に写ることになります。そしてゲームの画面は一般的に
			１秒間に６０回ほど画面の内容を更新するのでそれは結果的に『画面がちらついて見苦しい』ことに繋がります。<BR>
			　ですので描画処理自体はプレイヤーの見えないところで行い、画面の更新処理が終った後にプレイヤーの見ている
			表画面に写すことによってそのちらつきを無くしているのです。<BR><BR><BR>


			　さてその裏画面ですがＤＸライブラリでは <A HREF="dxfunc.html#R4N6"><B>SetDrawScreen</B></A> 関数と <A HREF="dxfunc.html#R4N7"><B>ScreenFlip</B></A> 関数によって裏画面処理手段を提供しています。<BR>
			　SetDrawScreen 関数は各種描画関数の描画先を表画面にするのか、裏画面にするのかを決めることが出来、
			 ScreenFlip 関数で裏画面に描画された内容を表画面に反映させることが出来るようになっています。<BR>

			　使用例のプログラムは各関数のサンプルプログラムを参照して下さい。<BR><BR><BR><BR>




			　<FONT COLOR="#007712"><A NAME="M6">ゲームの進行速度とリフレッシュレート</A></FONT><BR><BR>

			　<FONT COLOR="#8b40a4">ゲームの進行速度</FONT><BR><BR>
			
			　ゲームのアクションゲームなどではなぜキャラクター達が滑らかに移動しているように見えるのか、それは
			直感的に説明すれば<FONT COLOR="#770000">少しだけ動かしては表示</FONT>し、また<FONT COLOR="#770000">少しだけ動かしては表示</FONT>する、というものを繰り返して
			いるからですが、ではひとつの<FONT COLOR="#770000">『少しだけ動かす』</FONT>作業のうちに現実ではどれほどの時間が経過しているの
			でしょうか？<BR><BR>

			　当然何の処理もせず『少しだけ動かして表示』を繰り返せば、それは<FONT COLOR="#770000">パソコンの性能と１フレーム(コマ)当たりに
			かかっている作業量に比例</FONT>します。つまり<FONT COLOR="#770000">性能のよいパソコンではキャラクターは速く動き、悪いパソコンでは
			遅く、さらに画面上に出ているキャラクターの数でも動きの速さは変わって</FONT>しまいます。<BR>
			　これはとてもよろしくありません。<BR><BR>

			　そこで一般では『<FONT COLOR="#770000">１フレーム当たりどのくらいの時間が経過するか</FONT>』または『<FONT COLOR="#770000">１フレーム処理する間にどの
			程度時間が経過したか</FONT>』などを決め、又は取得し、それに応じてゲームの進行速度を一定に保つようにする処理を
			施します。<BR><BR><BR>


			　<FONT COLOR="#8b40a4">コンシューマゲーム機のゲーム(ＴＶゲーム)の場合</FONT><BR><BR>

			　家庭用テレビで稼動するＴＶゲームでは１フレーム当たり６０分の１秒経過することを前提にゲームを設計します。<BR>
			　何故なら<FONT COLOR="#770000">家庭用テレビでは１秒間に６０回画面の表示内容が更新される</FONT>からです。(厳密には半６０ですがここで
			の説明は割愛します)画面の秒間更新回数が６０なのに対してゲームの１フレーム当たりの経過時間を６０分の１
			以下にしてもタイミングが合わないので色々と都合が悪いのは説明無しでわかると思います。<BR><BR><BR>


			　<FONT COLOR="#8b40a4">パソコンのゲームの場合</FONT><BR><BR>

			　ではパソコンの場合は、といいますとディスプレイの１秒間あたりの更新回数(<FONT COLOR="#770000">リフレッシュレート</FONT>といいます)は
			<FONT COLOR="#770000">可変で固定ではありません</FONT>、つまり６０の場合もあれば８０や１２０の時もあるのです。<BR>
			　リフレッシュレートは皆さんも知ってのとおり設定で変更することは可能ですが『<FONT COLOR="#770000">このゲームをやる時はリフレ
			ッシュレートを６０にしてプレイしてください</FONT>』というのはあまり現実的ではありません。ですのでＴＶゲームと
			は逆にこちらが<FONT COLOR="#770000">リフレッシュレートに合わせてゲームの１フレーム当たりの経過時間を変更してやる</FONT>必要があります。<BR><BR>

			　そうするにはどうすればよいか、をこれから説明します。<BR>
			　まず<FONT COLOR="#770000">画面が１回更新されるのに何秒、いえ何ミリ秒経過しているかを得る必要</FONT>があります。それを実現するには
			ＤＸライブラリの <A HREF="dxfunc.html#R4N7">ScreenFlip</A> 関数を使用します。関数の説明にはありませんが、実はこの関数で裏画面の
			内容が表画面へ反映されるときは、<FONT COLOR="#770000">ディスプレイが画面の表示内容更新を終了した後という決まり</FONT>があるので１回
			ScreenFlip 関数を使用した後にすぐまた ScreenFlip 関数を使用すれば関数から処理が戻ってくるまでに
			<FONT COLOR="#770000">画面が１回更新されるまでの時間がかかる</FONT>ことになります。つまりこれを利用して画面表示内容が一回更新される
			までに経過している時間を取得する、というわけです。<BR><BR>

			　具体的には一定時間( 以下のサンプルでは０．５秒 )ScreenFlip を実行し続け、時間内に実行できた ScreenFlip の回数と、
			計測時間から一回画面が更新されるに当たりどれだけ時間が経過しているかを計測します。<BR>
			　プログラムとしては以下のようになります。<BR><BR>

<FONT COLOR="#006600"><PRE>
	int FrameTime, ScreenFlipCount, StartTime ;

	// ScreenFlip を実行した回数を数えるカウンタを初期化
	ScreenFlipCount = 0 ;

	// 画面が１回更新されるまで待つ
	ScreenFlip() ;

	// 計測開始時刻を保存
	StartTime = GetNowCount() ;

	// ０．５秒間に実行できる ScreenFlip の回数を計測
	for(;;)
	{
		// 画面が１回更新されるまで待つ
		ScreenFlip() ;

		// 計測開始から0.5秒経過していたらループから抜ける
		if( GetNowCount() - StartTime >= 500 )
			break ;

		// ScreenFlip を実行した回数をインクリメント
		ScreenFlipCount ++ ;
	}

	// ScreenFlip を実行した回数と計測時間から画面一回更新辺りの時間を算出する
	FrameTime = 500 / ScreenFlipCount ;
</PRE></FONT>

			<BR><BR>

			　<A HREF="dxfunc.html#R7N1">GetNowCount</A> 関数は１０００分の１ミリ単位のカウントを返すので、このプログラムで得られる１リフレッシュ当たりの
			時間もミリ秒単位の値となります。更に精度を求める場合は <A HREF="dxfunc.html#R7N2">GetNowHiPerformanceCount</A> 関数を使用します。<BR>
			　では得られた１リフレッシュ当たりの時間を使用してキャラクターの移動処理を行うにはどうすればよいか、ですが
			この当たりは説明されてもピンとこないと思いますので<A HREF="dxprogram.html#N13">サンプルプログラムコーナーの例</A>を参照して下さい。<BR><BR><BR><BR>




			　<FONT COLOR="#007712"><A NAME="M7">『前処理』のすすめ</A></FONT><BR><BR>

			　ＤＸライブラリでは <A HREF="dxfunc.html#R1N1"><B>DxLib_Init</B></A> 関数の前に行える処理が幾つかあります。<BR><BR>
			
			　<A HREF="dxfunc.html#R11N1"><B>ChangeWindowMode</B></A> , <A HREF="dxfunc.html#R4N1"><B>SetGraphMode</B></A> , <A HREF="dxfunc.html#R15N16"><B>SetScreenMemToVramFlag</B></A> ,<BR>
			  <A HREF="dxfunc.html#R15N14"><B>SetOutApplicationLogValidFlag</B></A> , <A HREF="dxfunc.html#R15N13"><B>SetWindowText</B></A> <BR><BR>

			　上記の関数は DxLib_Init 関数を使用する前に呼び出すことでそれぞれ、<FONT COLOR="#770000">最初からウインドウモードとして<BR>
			起動</FONT>したり、<FONT COLOR="#770000">最初から指定の画面モードで起動</FONT>したり、
			<FONT COLOR="#770000">最初から３Ｄグラフィックアクセラレータを使わない設定</FONT>にしたり、
			<FONT COLOR="#770000">AppLog.txt を作らない設定</FONT>にしたり、
			<FONT COLOR="#770000">ウインドウのシステムバーに書かれるタイトルを『DxLib』以外に変更</FONT>したり
			することが出来ます。<BR><BR><BR>

			　<FONT COLOR="#004400">仕様例(最初からウインドウモードで起動)</FONT><BR>

<FONT COLOR="#006600"><PRE>
// DxLib_Init 呼び出し前にウインドウモードに設定
ChangeWindowMode( TRUE ) ;

// その後 DxLib_Init を呼び出す
if( DxLib_Init() == -1 )
{
	// エラー発生時の処理
	return -1 ;
}
</PRE></FONT>
			<BR><BR><BR>


			　<FONT COLOR="#007712"><A NAME="M10">データ圧縮プログラムについてざっくり学ぶ</A></FONT><BR><BR>
			  
			　<FONT COLOR="#770000">圧縮</FONT>という言葉は聞いたことがあると思います。というかＤＸライブラリ自体圧縮されて
			配布されていますし、そもそも『プログラムをしよう』と思い立った方が『圧縮』をしらない
			可能性は低いと思うので、圧縮についての説明は割愛します。<BR><BR>
			
			　ともあれ、その『圧縮』をするプログラムについてざっくり学んでみたいという方向けの
			説明ページを作ってみましたので、興味のある方は<BR><BR>

			　　　<A HREF="lecture/Press/press.html">こちらをどうぞ</A><BR><BR>

			　内容は主に<BR><BR>

			<FONT COLOR="#770000">
			・ＢＭＰやＷＡＶなどの生データを晒したくないが晒さない手段を知らない<BR>
			・晒さない手段としてヘッダの一部を書き換えたり拡張子を変えるといった方法は使いたくない<BR>
			・圧縮プログラムを組んだことは無いが興味はある<BR>
			・組んだことはあるがランレングス圧縮くらいしかない<BR><BR>
			</FONT>

			　という方向けです。<BR><BR>

			<HR>
			<A HREF=index.html>戻る</A><BR><BR>
		</B></FONT>
		</TD></TR>
	</TABLE>
	</BODY>
</HTML>